{
  "title": "22 errors, 76 pass in 2h 35m 41s",
  "summary": "‚Äá‚Äà228 files‚ÄÑ‚ÄÉ‚Äá‚Äà228 suites‚ÄÑ‚ÄÉ‚ÄÇ2h 35m 41s ‚è±Ô∏è\n‚Äá‚Äà‚Äá98 tests‚ÄÉ‚Äá‚Äà‚Äá76 ‚úÖ‚ÄÉ0 üí§‚ÄÉ0 ‚ùå‚ÄÉ22 üî•\n1‚Äà193 runs‚Ää‚ÄÉ1‚Äà159 ‚úÖ‚ÄÉ0 üí§‚ÄÉ0 ‚ùå‚ÄÉ34 üî•\n\nResults for commit c5ad0756.\n",
  "conclusion": "failure",
  "stats": {
    "files": 228,
    "errors": [],
    "suites": 228,
    "duration": 9341,
    "suite_details": [
      {
        "name": "validation_wokwi_esp32s2_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_unity",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c6_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_i2c_master0",
        "tests": 6,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_superpi",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32s2_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_touch0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32p4_fibonacci",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c6_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_nvs",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_timer0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c5_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_fs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32s3_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_ramspeed",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32p4_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_timer",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32h2_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_uart",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32h2_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_coremark",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32p4_touch",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32h2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_democfg1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_hello_world",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32h2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_uart",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_psramspeed",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c5_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_fs",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32p4_psram",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32h2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_linpack_float",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_timer0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_periman",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c6_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_periman",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_unity",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s3_wifi2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32p4_nvs",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_timer0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_fs",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32c5_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_i2c_master0",
        "tests": 6,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_hello_world",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c6_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_nvs",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32c5_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_linpack_double",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32s2_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32h2_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_timer",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32p4_psram0",
        "tests": 8,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      }
    ],
    "tests": 98,
    "tests_succ": 76,
    "tests_skip": 0,
    "tests_fail": 0,
    "tests_error": 22,
    "runs": 1193,
    "runs_succ": 1159,
    "runs_skip": 0,
    "runs_fail": 0,
    "runs_error": 34,
    "commit": "c5ad0756a79339f409e48f3e76434fce293ee445"
  },
  "annotations": [
    {
      "path": "validation.unity",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/validation/unity/esp32c3/unity_missing_0.xml\n./test_errors/test-results-hardware/tests/validation/unity/esp32p4/unity_missing_0.xml",
      "title": "All 2 runs with error: missing-run (validation.unity)",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation/nvs/test_nvs.py",
      "start_line": 3,
      "end_line": 3,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/nvs/esp32s2/nvs0.xml‚ÄÉ[took 3s]\n./artifacts/test-results-hw/validation/nvs/esp32s2/nvs1.xml‚ÄÉ[took 3s]",
      "title": "2 out of 37 runs with error: test_nvs (validation.nvs.test_nvs)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x77d5c72d2120>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x77d5c73a0ce0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x77d5c72da0c0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x77d5c72f8830>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/nvs/build0.tmp/nvs.ino.bootloader.bin'>), (32768, <_io....vs.ino.partitions.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/nvs/build0.tmp/nvs.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xe9\\x03\\x02/8\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?t\\x11\\x00\\x00P\\x00\\...\\x00\\x00\\x00\\x00?\\x89\\x82\\x9e\\xb9\\xb3a\\xce\\x8a\\x99\\x13\\xdc\\xf5\\xd6\\x04>\\xb0u\\xfe\\xea\\xe6\\xackg)\\x14\\xad\\x87\\xa3Ml\\xce('\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/8\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?t\\x11\\x00\\...\\x10\\xaf\\xc8\\xc9\\xe6\\xbap\\xf9%\\x9f\\xadfc\\x8a\\xe1\\xd3\\x91', '/root/.arduino/tests/esp32s2/nvs/build0.tmp/nvs.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "validation/periman/test_periman.py",
      "start_line": 3,
      "end_line": 3,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/periman/esp32s2/periman.xml‚ÄÉ[took 3s]",
      "title": "1 out of 6 runs with error: test_periman (validation.periman.test_periman)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7a25b3e63320>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7a25b3ec1c70>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7a25b3e6a160>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x7a25b3e63da0>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/periman/build.tmp/periman.ino.bootloader.bin'>), (32768...partitions.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/periman/build.tmp/periman.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\x00\\x00P\\...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00f>}c\\x17\\x84\\x154\\x14\\x10%0\\x1c\\x03\\xaaF\\x80Z\\xed\\x895\\xfa\\xdd\\x12\\x1c*6\\'\\xcb+i;L'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...3\\xf6z8\\x86tf]y\\xbcj\\xf8\\x1e&\\x81\\x82\\xbe\\xe1\\x80', '/root/.arduino/tests/esp32s2/periman/build.tmp/periman.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "validation/hello_world/test_hello_world.py",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/hello_world/esp32s2/hello_world.xml‚ÄÉ[took 3s]",
      "title": "1 out of 13 runs with error: test_hello_world (validation.hello_world.test_hello_world)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x792290ab7380>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x792290b85220>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x792290abe020>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x792290ad8bf0>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/hello_world/build.tmp/hello_world.ino.bootloader.bin'>)...ns.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/hello_world/build.tmp/hello_world.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\x00\\x00P\\...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00f>}c\\x17\\x84\\x154\\x14\\x10%0\\x1c\\x03\\xaaF\\x80Z\\xed\\x895\\xfa\\xdd\\x12\\x1c*6\\'\\xcb+i;L'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...'b\\xa4\\xdc\\xea,\\xc7\\x8e\\x0eHr\\xbc\\x19\\x1e', '/root/.arduino/tests/esp32s2/hello_world/build.tmp/hello_world.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "performance.superpi",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/superpi/esp32p4/superpi_missing_0.xml",
      "title": "missing-run (performance.superpi) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation.nvs",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/validation/nvs/esp32c3/nvs_missing_0.xml\n./test_errors/test-results-hardware/tests/validation/nvs/esp32c3/nvs_missing_1.xml\n./test_errors/test-results-hardware/tests/validation/nvs/esp32p4/nvs_missing_0.xml\n./test_errors/test-results-hardware/tests/validation/nvs/esp32p4/nvs_missing_1.xml\n./test_errors/test-results-hardware/tests/validation/nvs/esp32p4/nvs_missing_2.xml\n./test_errors/test-results-hardware/tests/validation/nvs/esp32p4/nvs_missing_3.xml",
      "title": "All 6 runs with error: missing-run (validation.nvs)",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation/touch/test_touch.py",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/touch/esp32s2/touch.xml‚ÄÉ[took 3s]",
      "title": "test_touch (validation.touch.test_touch) with error",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x712e8a7ef110>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x712e8a74fe90>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x712e8a7f60c0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x712e8a7ef8c0>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/touch/build.tmp/touch.ino.bootloader.bin'>), (32768, <_...ino.partitions.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/touch/build.tmp/touch.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\x00\\x00P\\...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00f>}c\\x17\\x84\\x154\\x14\\x10%0\\x1c\\x03\\xaaF\\x80Z\\xed\\x895\\xfa\\xdd\\x12\\x1c*6\\'\\xcb+i;L'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...4\\xfdo\\xc16\\xda>\\x8c\\xe3t\\x83\\x0e\\xc8\\xbc\\xfcT,\\x1b8d', '/root/.arduino/tests/esp32s2/touch/build.tmp/touch.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "performance.fibonacci",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/fibonacci/esp32p4/fibonacci_missing_0.xml",
      "title": "missing-run (performance.fibonacci) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation/timer/test_timer.py",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/timer/esp32s2/timer.xml‚ÄÉ[took 3s]",
      "title": "test_timer (validation.timer.test_timer) with error",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7b957a363200>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7b957bfad910>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7b957a36a0c0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x7b957a993b60>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/timer/build.tmp/timer.ino.bootloader.bin'>), (32768, <_...ino.partitions.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/timer/build.tmp/timer.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\x00\\x00P\\...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00f>}c\\x17\\x84\\x154\\x14\\x10%0\\x1c\\x03\\xaaF\\x80Z\\xed\\x895\\xfa\\xdd\\x12\\x1c*6\\'\\xcb+i;L'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...a8\\x00g\\xb7a\\x9f\\xbe\\xc2\\x8b\\x1e_\\xe2\\xb5\\xae\\xf0\\xac', '/root/.arduino/tests/esp32s2/timer/build.tmp/timer.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "validation/fs/test_fs.py",
      "start_line": 3,
      "end_line": 3,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/fs/esp32s2/fs.xml‚ÄÉ[took 3s]",
      "title": "test_fs (validation.fs.test_fs) with error",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7d6d75b46f30>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7d6d7606d1c0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7d6d75b4e020>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x7d6d75b47f80>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/fs/build.tmp/fs.ino.bootloader.bin'>), (32768, <_io.Buf...mp/fs.ino.partitions.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/fs/build.tmp/fs.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xaaP\\x01\\x02\\x00\\x90\\x00\\x00\\x00P\\x00\\x00nvs\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa...ff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...bcAT\\x08\\x03\\xbb\\x9e\\xbc\\x985\\xd6c\\xf6\\x99\\nw\\xcb\\x82\\x9fk?', '/root/.arduino/tests/esp32s2/fs/build.tmp/fs.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "performance.ramspeed",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/ramspeed/esp32p4/ramspeed_missing_0.xml",
      "title": "missing-run (performance.ramspeed) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation.timer",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/validation/timer/esp32c3/timer_missing_0.xml\n./test_errors/test-results-hardware/tests/validation/timer/esp32p4/timer_missing_0.xml",
      "title": "All 2 runs with error: missing-run (validation.timer)",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation.uart",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/validation/uart/esp32c3/uart_missing_0.xml\n./test_errors/test-results-hardware/tests/validation/uart/esp32p4/uart_missing_0.xml",
      "title": "All 2 runs with error: missing-run (validation.uart)",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "performance.coremark",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/coremark/esp32p4/coremark_missing_0.xml",
      "title": "missing-run (performance.coremark) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation.touch",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/validation/touch/esp32p4/touch_missing_0.xml",
      "title": "missing-run (validation.touch) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation.hello_world",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/validation/hello_world/esp32c3/hello_world_missing_0.xml\n./test_errors/test-results-hardware/tests/validation/hello_world/esp32p4/hello_world_missing_0.xml",
      "title": "All 2 runs with error: missing-run (validation.hello_world)",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "performance.psramspeed",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/psramspeed/esp32p4/psramspeed_missing_0.xml",
      "title": "missing-run (performance.psramspeed) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation.fs",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/validation/fs/esp32c3/fs_missing_0.xml\n./test_errors/test-results-hardware/tests/validation/fs/esp32p4/fs_missing_0.xml",
      "title": "All 2 runs with error: missing-run (validation.fs)",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation.psram",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/validation/psram/esp32p4/psram_missing_0.xml",
      "title": "missing-run (validation.psram) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "performance.linpack_float",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/linpack_float/esp32p4/linpack_float_missing_0.xml",
      "title": "missing-run (performance.linpack_float) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "validation.periman",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/validation/periman/esp32c3/periman_missing_0.xml\n./test_errors/test-results-hardware/tests/validation/periman/esp32p4/periman_missing_0.xml",
      "title": "All 2 runs with error: missing-run (validation.periman)",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "performance.linpack_double",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/linpack_double/esp32p4/linpack_double_missing_0.xml",
      "title": "missing-run (performance.linpack_double) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": ".github",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "notice",
      "message": "There are 98 tests, see \"Raw output\" for the full list of tests.",
      "title": "98 tests found",
      "raw_details": "auto_baudrate_test\nbasic_transmission_test\nbegin_when_running_test\nchange_baudrate_test\nchange_clock\nchange_cpu_frequency_test\nchange_pins_test\ndisabled_uart_calls_test\nenabled_uart_calls_test\nend_when_stopped_test\nhardware_flow_control_test\nperformance.coremark ‚Äë missing-run\nperformance.coremark.test_coremark ‚Äë test_coremark\nperformance.fibonacci ‚Äë missing-run\nperformance.fibonacci.test_fibonacci ‚Äë test_fibonacci\nperformance.linpack_double ‚Äë missing-run\nperformance.linpack_double.test_linpack_double ‚Äë test_linpack_double\nperformance.linpack_float ‚Äë missing-run\nperformance.linpack_float.test_linpack_float ‚Äë test_linpack_float\nperformance.psramspeed ‚Äë missing-run\nperformance.psramspeed.test_psramspeed ‚Äë test_psramspeed\nperformance.ramspeed ‚Äë missing-run\nperformance.ramspeed.test_ramspeed ‚Äë test_ramspeed\nperformance.superpi ‚Äë missing-run\nperformance.superpi.test_superpi ‚Äë test_superpi\nperiman_test\npsram_found\nresize_buffers_test\nrtc_run_clock\nrtc_set_time\nscan_bus\nscan_bus_with_wifi\nswap_pins\ntest_api\ntest_append_behavior\ntest_basic_write_and_read\ntest_binary_incremental_with_size_tracking\ntest_binary_write_and_seek\ntest_calloc_success\ntest_dir_ops_and_list\ntest_directory_operations_edge_cases\ntest_empty_file_operations\ntest_error_cases\ntest_fail\ntest_file_truncation_and_overwrite\ntest_free_space_tracking\ntest_info_sanity\ntest_large_file_operations\ntest_malloc_fail\ntest_malloc_success\ntest_max_open_files_limit\ntest_memcpy\ntest_memset_all_ones\ntest_memset_all_zeroes\ntest_memset_alternating\ntest_memset_random\ntest_multiple_file_handles\ntest_nonexistent_spi_interface\ntest_pass\ntest_realloc_success\ntest_rename_and_remove\ntest_sd_basic\ntest_sd_dir\ntest_sd_directory_listing\ntest_sd_file_append_operations\ntest_sd_file_count_in_directory\ntest_sd_file_operations\ntest_sd_file_size_operations\ntest_sd_large_file_operations\ntest_sd_nested_directories\ntest_sd_open_limit\ntest_seek_edge_cases\ntest_touch_errors\ntest_touch_interrtupt\ntest_touch_read\ntest_write_read_patterns\ntimer_clock_select_test\ntimer_divider_test\ntimer_interrupt_test\ntimer_read_test\nvalidation.democfg.test_democfg ‚Äë test_cfg\nvalidation.fs ‚Äë missing-run\nvalidation.fs.test_fs ‚Äë test_fs\nvalidation.gpio.test_gpio ‚Äë test_gpio\nvalidation.hello_world ‚Äë missing-run\nvalidation.hello_world.test_hello_world ‚Äë test_hello_world\nvalidation.nvs ‚Äë missing-run\nvalidation.nvs.test_nvs ‚Äë test_nvs\nvalidation.periman ‚Äë missing-run\nvalidation.periman.test_periman ‚Äë test_periman\nvalidation.psram ‚Äë missing-run\nvalidation.timer ‚Äë missing-run\nvalidation.timer.test_timer ‚Äë test_timer\nvalidation.touch ‚Äë missing-run\nvalidation.touch.test_touch ‚Äë test_touch\nvalidation.uart ‚Äë missing-run\nvalidation.unity ‚Äë missing-run\nvalidation.wifi.test_wifi ‚Äë test_wifi"
    }
  ],
  "check_url": "https://github.com/espressif/arduino-esp32/runs/60420652452",
  "formatted": {
    "stats": {
      "files": "228",
      "errors": [],
      "suites": "228",
      "duration": "9‚Äà341",
      "suite_details": [
        {
          "name": "validation_wokwi_esp32s2_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_unity",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c6_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_i2c_master0",
          "tests": 6,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_superpi",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32s2_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_touch0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32p4_fibonacci",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c6_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_nvs",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_timer0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c5_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_fs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32s3_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_ramspeed",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32p4_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_timer",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32h2_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_uart",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32h2_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_coremark",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32p4_touch",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32h2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_democfg1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_hello_world",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32h2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_uart",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_psramspeed",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c5_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_fs",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32p4_psram",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32h2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_linpack_float",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_timer0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_periman",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c6_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_periman",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_unity",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s3_wifi2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32p4_nvs",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_timer0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_fs",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32c5_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_i2c_master0",
          "tests": 6,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_hello_world",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c6_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_nvs",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32c5_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_linpack_double",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32s2_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32h2_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_timer",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32p4_psram0",
          "tests": 8,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        }
      ],
      "tests": "98",
      "tests_succ": "76",
      "tests_skip": "0",
      "tests_fail": "0",
      "tests_error": "22",
      "runs": "1‚Äà193",
      "runs_succ": "1‚Äà159",
      "runs_skip": "0",
      "runs_fail": "0",
      "runs_error": "34",
      "commit": "c5ad0756a79339f409e48f3e76434fce293ee445"
    }
  }
}