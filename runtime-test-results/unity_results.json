{
  "title": "16 errors, 69 pass in 2h 34m 4s",
  "summary": "‚Äá‚Äà228 files‚ÄÑ‚ÄÉ‚Äá‚Äà228 suites‚ÄÑ‚ÄÉ‚ÄÇ2h 34m 4s ‚è±Ô∏è\n‚Äá‚Äà‚Äá85 tests‚ÄÉ‚Äá‚Äà‚Äá69 ‚úÖ‚ÄÉ0 üí§‚ÄÉ0 ‚ùå‚ÄÉ16 üî•\n1‚Äà312 runs‚Ää‚ÄÉ1‚Äà287 ‚úÖ‚ÄÉ0 üí§‚ÄÉ0 ‚ùå‚ÄÉ25 üî•\n\nResults for commit 6cfa93f4.\n",
  "conclusion": "failure",
  "stats": {
    "files": 228,
    "errors": [],
    "suites": 228,
    "duration": 9244,
    "suite_details": [
      {
        "name": "validation_hardware_esp32h2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32h2_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32p4_i2c_master0",
        "tests": 6,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32s2_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_timer0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32c5_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32p4_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s2_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_timer0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32s3_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_timer0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s2_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_psram0",
        "tests": 8,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32h2_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_i2c_master0",
        "tests": 6,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_fs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c6_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_democfg1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s3_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s3_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_touch0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c6_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_uart0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_unity0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_psram0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32h2_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      }
    ],
    "tests": 85,
    "tests_succ": 69,
    "tests_skip": 0,
    "tests_fail": 0,
    "tests_error": 16,
    "runs": 1312,
    "runs_succ": 1287,
    "runs_skip": 0,
    "runs_fail": 0,
    "runs_error": 25,
    "commit": "6cfa93f4b4e2c0e3cf492e4a45780bfbe757fcd4"
  },
  "annotations": [
    {
      "path": "validation/nvs/test_nvs.py",
      "start_line": 3,
      "end_line": 3,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/nvs/esp32p4/nvs0.xml‚ÄÉ[took 1s]\n./artifacts/test-results-hw/validation/nvs/esp32p4/nvs1.xml‚ÄÉ[took 1s]\n./artifacts/test-results-hw/validation/nvs/esp32p4/nvs2.xml‚ÄÉ[took 1s]\n./artifacts/test-results-hw/validation/nvs/esp32p4/nvs3.xml‚ÄÉ[took 1s]",
      "title": "4 out of 43 runs with error: test_nvs (validation.nvs.test_nvs)",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x72fa75443860>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x72fa753dbe30>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x72fa75452520>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x72fa7546cd40>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x72fa756b5da0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x72fa7565e020>\nrequest = <SubRequest 'serial' for <Function test_nvs>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x72fa75443860>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x72fa753dbe30>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "performance/fibonacci/test_fibonacci.py",
      "start_line": 17,
      "end_line": 17,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/fibonacci/esp32p4/fibonacci.xml‚ÄÉ[took 1s]\n./artifacts/test-results-hw/performance/fibonacci/esp32s2/fibonacci.xml‚ÄÉ[took 3s]",
      "title": "2 out of 8 runs with error: test_fibonacci (performance.fibonacci.test_fibonacci)",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x76edb710fa10>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x76edb710ed80>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x76edb711a520>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x76edb7134620>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x76edb737dda0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x76edb7326020>\nrequest = <SubRequest 'serial' for <Function test_fibonacci>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x76edb710fa10>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x76edb710ed80>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "performance/linpack_double/test_linpack_double.py",
      "start_line": 5,
      "end_line": 5,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/linpack_double/esp32p4/linpack_double.xml‚ÄÉ[took 1s]\n./artifacts/test-results-hw/performance/linpack_double/esp32s2/linpack_double.xml‚ÄÉ[took 3s]",
      "title": "2 out of 8 runs with error: test_linpack_double (performance.linpack_double.test_linpack_double)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x77c7cc7d7890>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x77c7cdb11460>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x77c7cc7e25c0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x77c7cc7fd220>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/linpack_double/build.tmp/linpack_double.ino.bootloader....'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/linpack_double/build.tmp/linpack_double.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\x00\\x00P\\...00\\x00\\x00U\\xdb\\x14\\xd3?\\xaa\\xaa7w\\xa9\\xf5\\xeb\\xad\\xd2\\x06K@\\xb4\\x15\\x8a\\xc4\\xd8\\xeew\\x15\\x83\\x83\\xda\\xa9\\x84w\\xe1\\xe4'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...x14\\x832\\x9b\\x18p\\x9cZ\\xb7\\x077\\x8d', '/root/.arduino/tests/esp32s2/linpack_double/build.tmp/linpack_double.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "performance/ramspeed/test_ramspeed.py",
      "start_line": 7,
      "end_line": 7,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/ramspeed/esp32p4/ramspeed.xml‚ÄÉ[took 1s]\n./artifacts/test-results-hw/performance/ramspeed/esp32s2/ramspeed.xml‚ÄÉ[took 3s]",
      "title": "2 out of 8 runs with error: test_ramspeed (performance.ramspeed.test_ramspeed)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7f17cc6a76b0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7f17cc60e120>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f17cc6b2520>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x7f17cc6cd2e0>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/ramspeed/build.tmp/ramspeed.ino.bootloader.bin'>), (327...rtitions.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/ramspeed/build.tmp/ramspeed.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\x00\\x00P\\...00\\x00\\x00U\\xdb\\x14\\xd3?\\xaa\\xaa7w\\xa9\\xf5\\xeb\\xad\\xd2\\x06K@\\xb4\\x15\\x8a\\xc4\\xd8\\xeew\\x15\\x83\\x83\\xda\\xa9\\x84w\\xe1\\xe4'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...\\x0c\\xdf0\\xbd5\\xe2\\xd2 \\x82#`P\\xd4G\\xbd\\x94\\xb0', '/root/.arduino/tests/esp32s2/ramspeed/build.tmp/ramspeed.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "performance/linpack_float/test_linpack_float.py",
      "start_line": 5,
      "end_line": 5,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/linpack_float/esp32p4/linpack_float.xml‚ÄÉ[took 1s]\n./artifacts/test-results-hw/performance/linpack_float/esp32s2/linpack_float.xml‚ÄÉ[took 3s]",
      "title": "2 out of 8 runs with error: test_linpack_float (performance.linpack_float.test_linpack_float)",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7400be33faa0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7400be5be2d0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7400be34a520>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x7400be3653d0>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x7400be5adda0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x7400be556020>\nrequest = <SubRequest 'serial' for <Function test_linpack_float>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7400be33faa0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7400be5be2d0>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "validation/periman/test_periman.py",
      "start_line": 3,
      "end_line": 3,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/periman/esp32p4/periman.xml‚ÄÉ[took 1s]",
      "title": "1 out of 8 runs with error: test_periman (validation.periman.test_periman)",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7e586a6c7860>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7e586aa03530>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7e586a6d25c0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x7e586a6ed550>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x7e586a93dda0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x7e586a8e6020>\nrequest = <SubRequest 'serial' for <Function test_periman>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7e586a6c7860>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7e586aa03530>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "performance/superpi/test_superpi.py",
      "start_line": 5,
      "end_line": 5,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/superpi/esp32p4/superpi.xml‚ÄÉ[took 1s]\n./artifacts/test-results-hw/performance/superpi/esp32s2/superpi.xml‚ÄÉ[took 3s]",
      "title": "2 out of 8 runs with error: test_superpi (performance.superpi.test_superpi)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7eb2087d3710>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7eb20890a120>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7eb2087de520>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x7eb2087fad20>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/superpi/build.tmp/superpi.ino.bootloader.bin'>), (32768...partitions.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/superpi/build.tmp/superpi.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xaaP\\x01\\x02\\x00\\x90\\x00\\x00\\x00P\\x00\\x00nvs\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa...ff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...0c\\x9a9\\xa8\\xb7r\\x9b\\xac\\x8a\\xee\\x9a\\xe8\\xd1o\\xba', '/root/.arduino/tests/esp32s2/superpi/build.tmp/superpi.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "validation/hello_world/test_hello_world.py",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/hello_world/esp32p4/hello_world.xml‚ÄÉ[took 1s]",
      "title": "1 out of 15 runs with error: test_hello_world (validation.hello_world.test_hello_world)",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x779d0aaeb4a0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x779d0aaea8a0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x779d0aaf6480>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x779d0ab08b60>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x779d0ad61da0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x779d0ad0a020>\nrequest = <SubRequest 'serial' for <Function test_hello_world>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x779d0aaeb4a0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x779d0aaea8a0>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "validation/timer/test_timer.py",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/timer/esp32p4/timer.xml‚ÄÉ[took 1s]",
      "title": "test_timer (validation.timer.test_timer) with error",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x77d32c0eab70>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x77d32c0816d0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x77d32c0fa520>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x77d32c114260>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x77d32c35dda0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x77d32c306020>\nrequest = <SubRequest 'serial' for <Function test_timer>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x77d32c0eab70>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x77d32c0816d0>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "performance/psramspeed/test_psramspeed.py",
      "start_line": 7,
      "end_line": 7,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/psramspeed/esp32p4/psramspeed.xml‚ÄÉ[took 1s]",
      "title": "1 out of 5 runs with error: test_psramspeed (performance.psramspeed.test_psramspeed)",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x77d936733b30>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x77d936df4260>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x77d93673e480>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x77d9369bcc50>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x77d9369a9da0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x77d936952020>\nrequest = <SubRequest 'serial' for <Function test_psramspeed>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x77d936733b30>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x77d936df4260>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "performance/coremark/test_coremark.py",
      "start_line": 5,
      "end_line": 5,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/coremark/esp32p4/coremark.xml‚ÄÉ[took 1s]\n./artifacts/test-results-hw/performance/coremark/esp32s2/coremark.xml‚ÄÉ[took 3s]",
      "title": "2 out of 8 runs with error: test_coremark (performance.coremark.test_coremark)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x762784be39b0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x762784cbd7f0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x762784bee520>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x762784c08980>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/coremark/build.tmp/coremark.ino.bootloader.bin'>), (327...rtitions.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/coremark/build.tmp/coremark.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\x00\\x00P\\...00\\x00\\x00U\\xdb\\x14\\xd3?\\xaa\\xaa7w\\xa9\\xf5\\xeb\\xad\\xd2\\x06K@\\xb4\\x15\\x8a\\xc4\\xd8\\xeew\\x15\\x83\\x83\\xda\\xa9\\x84w\\xe1\\xe4'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...x18z\\x13w\\x89?\\xbb\\xe2w\\xbcV\\x03\\xe9\\xbe[A\\x9b*', '/root/.arduino/tests/esp32s2/coremark/build.tmp/coremark.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "validation/fs/test_fs.py",
      "start_line": 3,
      "end_line": 3,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/fs/esp32p4/fs.xml‚ÄÉ[took 1s]",
      "title": "test_fs (validation.fs.test_fs) with error",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x721976e1baa0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7219770a8320>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x721976e2a480>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x721976e44fb0>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x721977095da0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x72197703e020>\nrequest = <SubRequest 'serial' for <Function test_fs>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x721976e1baa0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7219770a8320>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "validation/touch/test_touch.py",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/touch/esp32p4/touch.xml‚ÄÉ[took 1s]",
      "title": "test_touch (validation.touch.test_touch) with error",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7836a4c37470>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7836a4d1be60>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7836a4c42520>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x7836a4c5cb00>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x7836a4eadda0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x7836a4e56020>\nrequest = <SubRequest 'serial' for <Function test_touch>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7836a4c37470>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7836a4d1be60>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "validation/uart/test_uart.py",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/uart/esp32p4/uart.xml‚ÄÉ[took 1s]",
      "title": "test_uart (validation.uart.test_uart) with error",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x792f92e0ba70>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x792f934c4530>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x792f92e1a480>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x792f92e35250>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x792f9307dda0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x792f93026020>\nrequest = <SubRequest 'serial' for <Function test_uart>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x792f92e0ba70>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x792f934c4530>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "validation/unity/test_unity.py",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/unity/esp32p4/unity.xml‚ÄÉ[took 1s]",
      "title": "test_unity (validation.unity.test_unity) with error",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7851783aaf90>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x78517862dd60>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7851783ba480>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x7851783d4950>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x78517861dda0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x7851785c6020>\nrequest = <SubRequest 'serial' for <Function test_unity>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7851783aaf90>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x78517862dd60>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": "validation/psram/test_psram.py",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/psram/esp32p4/psram.xml‚ÄÉ[took 1s]",
      "title": "test_psram (validation.psram.test_psram) with error",
      "raw_details": "failed on setup with \"RuntimeError: generator raised StopIteration\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7b19645073e0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7b19645068d0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7b1964512480>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:688: in write_flash_cli\n    attach_flash(ctx.obj[\"esp\"], kwargs.pop(\"spi_connection\", None))\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:1112: in attach_flash\n    flash_id = esp.flash_id()\n               ^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1091: in flash_id\n    self.cache[\"flash_id\"] = self.run_spiflash_command(SPIFLASH_RDID, b\"\", 24)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:1653: in run_spiflash_command\n    old_spi_usr = self.read_reg(SPI_USR_REG)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:901: in read_reg\n    return self.check_command(\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:565: in check_command\n    val, data = self.command(op, data, chk, timeout=timeout)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:495: in command\n    p = self.read()\n        ^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32p4.ESP32P4StubLoader object at 0x7b1964524b00>\n\n    def read(self):\n        \"\"\"Read a SLIP packet from the serial port\"\"\"\n>       return next(self._slip_reader)\n               ^^^^^^^^^^^^^^^^^^^^^^^\nE       StopIteration\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:431: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_and_report.<locals>.<lambda> at 0x7b196477dda0>\nwhen = 'setup'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: Callable[[], TResult],\n        when: Literal[\"collect\", \"setup\", \"call\", \"teardown\"],\n        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,\n    ) -> CallInfo[TResult]:\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :type func: Callable[[], _pytest.runner.TResult]\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        instant = timing.Instant()\n        try:\n>           result: TResult | None = func()\n                                     ^^^^^^\n\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:245: in <lambda>\n    lambda: runtest_hook(item=item, **kwds),\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup\n    yield\n/usr/local/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:165: in pytest_runtest_setup\n    item.session._setupstate.setup(item)\n/usr/local/lib/python3.12/site-packages/_pytest/runner.py:523: in setup\n    col.setup()\n/usr/local/lib/python3.12/site-packages/_pytest/python.py:1723: in setup\n    self._request._fillfixtures()\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:707: in _fillfixtures\n    item.funcargs[argname] = self.getfixturevalue(argname)\n                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:539: in getfixturevalue\n    fixturedef = self._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1068: in execute\n    fixturedef = request._get_active_fixturedef(argname)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:627: in _get_active_fixturedef\n    fixturedef.execute(request=subrequest)\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1110: in execute\n    result: FixtureValue = ihook.pytest_fixture_setup(\n/usr/local/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__\n    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec\n    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:1202: in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nfixturefunc = <function serial at 0x7b1964726020>\nrequest = <SubRequest 'serial' for <Function test_psram>>\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7b19645073e0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7b19645068d0>}\n\n    def call_fixture_func(\n        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if inspect.isgeneratorfunction(fixturefunc):\n            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)\n            generator = fixturefunc(**kwargs)\n            try:\n>               fixture_result = next(generator)\n                                 ^^^^^^^^^^^^^^^\nE               RuntimeError: generator raised StopIteration\n\n/usr/local/lib/python3.12/site-packages/_pytest/fixtures.py:908: RuntimeError"
    },
    {
      "path": ".github",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "notice",
      "message": "There are 85 tests, see \"Raw output\" for the full list of tests.",
      "title": "85 tests found",
      "raw_details": "auto_baudrate_test\nbasic_transmission_test\nbegin_when_running_test\nchange_baudrate_test\nchange_clock\nchange_cpu_frequency_test\nchange_pins_test\ndisabled_uart_calls_test\nenabled_uart_calls_test\nend_when_stopped_test\nhardware_flow_control_test\nperformance.coremark.test_coremark ‚Äë test_coremark\nperformance.fibonacci.test_fibonacci ‚Äë test_fibonacci\nperformance.linpack_double.test_linpack_double ‚Äë test_linpack_double\nperformance.linpack_float.test_linpack_float ‚Äë test_linpack_float\nperformance.psramspeed.test_psramspeed ‚Äë test_psramspeed\nperformance.ramspeed.test_ramspeed ‚Äë test_ramspeed\nperformance.superpi.test_superpi ‚Äë test_superpi\nperiman_test\npsram_found\nresize_buffers_test\nrtc_run_clock\nrtc_set_time\nscan_bus\nscan_bus_with_wifi\nswap_pins\ntest_api\ntest_append_behavior\ntest_basic_write_and_read\ntest_binary_incremental_with_size_tracking\ntest_binary_write_and_seek\ntest_calloc_success\ntest_dir_ops_and_list\ntest_directory_operations_edge_cases\ntest_empty_file_operations\ntest_error_cases\ntest_fail\ntest_file_truncation_and_overwrite\ntest_free_space_tracking\ntest_info_sanity\ntest_large_file_operations\ntest_malloc_fail\ntest_malloc_success\ntest_max_open_files_limit\ntest_memcpy\ntest_memset_all_ones\ntest_memset_all_zeroes\ntest_memset_alternating\ntest_memset_random\ntest_multiple_file_handles\ntest_nonexistent_spi_interface\ntest_pass\ntest_realloc_success\ntest_rename_and_remove\ntest_sd_basic\ntest_sd_dir\ntest_sd_directory_listing\ntest_sd_file_append_operations\ntest_sd_file_count_in_directory\ntest_sd_file_operations\ntest_sd_file_size_operations\ntest_sd_large_file_operations\ntest_sd_nested_directories\ntest_sd_open_limit\ntest_seek_edge_cases\ntest_touch_errors\ntest_touch_interrtupt\ntest_touch_read\ntest_write_read_patterns\ntimer_clock_select_test\ntimer_divider_test\ntimer_interrupt_test\ntimer_read_test\nvalidation.democfg.test_democfg ‚Äë test_cfg\nvalidation.fs.test_fs ‚Äë test_fs\nvalidation.gpio.test_gpio ‚Äë test_gpio\nvalidation.hello_world.test_hello_world ‚Äë test_hello_world\nvalidation.nvs.test_nvs ‚Äë test_nvs\nvalidation.periman.test_periman ‚Äë test_periman\nvalidation.psram.test_psram ‚Äë test_psram\nvalidation.timer.test_timer ‚Äë test_timer\nvalidation.touch.test_touch ‚Äë test_touch\nvalidation.uart.test_uart ‚Äë test_uart\nvalidation.unity.test_unity ‚Äë test_unity\nvalidation.wifi.test_wifi ‚Äë test_wifi"
    }
  ],
  "check_url": "https://github.com/espressif/arduino-esp32/runs/62563039561",
  "formatted": {
    "stats": {
      "files": "228",
      "errors": [],
      "suites": "228",
      "duration": "9‚Äà244",
      "suite_details": [
        {
          "name": "validation_hardware_esp32h2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32h2_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32p4_i2c_master0",
          "tests": 6,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32s2_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_timer0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32c5_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32p4_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s2_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_timer0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32s3_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_timer0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s2_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_psram0",
          "tests": 8,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32h2_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_i2c_master0",
          "tests": 6,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_fs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c6_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_democfg1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s3_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s3_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_touch0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c6_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_uart0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_unity0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_psram0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32h2_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        }
      ],
      "tests": "85",
      "tests_succ": "69",
      "tests_skip": "0",
      "tests_fail": "0",
      "tests_error": "16",
      "runs": "1‚Äà312",
      "runs_succ": "1‚Äà287",
      "runs_skip": "0",
      "runs_fail": "0",
      "runs_error": "25",
      "commit": "6cfa93f4b4e2c0e3cf492e4a45780bfbe757fcd4"
    }
  }
}