{
  "title": "11 errors, 1 fail, 74 pass in 2h 40m 40s",
  "summary": "‚Äá‚Äà228 files‚ÄÑ‚ÄÉ‚Äá‚Äà228 suites‚ÄÑ‚ÄÉ‚ÄÇ2h 40m 40s ‚è±Ô∏è\n‚Äá‚Äà‚Äá86 tests‚ÄÉ‚Äá‚Äà‚Äá74 ‚úÖ‚ÄÉ0 üí§‚ÄÉ1 ‚ùå‚ÄÉ11 üî•\n1‚Äà376 runs‚Ää‚ÄÉ1‚Äà364 ‚úÖ‚ÄÉ0 üí§‚ÄÉ1 ‚ùå‚ÄÉ11 üî•\n\nResults for commit 411b5b19.\n",
  "conclusion": "failure",
  "stats": {
    "files": 228,
    "errors": [],
    "suites": 228,
    "duration": 9640,
    "suite_details": [
      {
        "name": "performance_hardware_esp32h2_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32c5_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_democfg1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_psram0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_timer0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_timer0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_psram0",
        "tests": 8,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_superpi",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_psram0",
        "tests": 8,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32p4_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_ramspeed",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c6_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_i2c_master0",
        "tests": 6,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32h2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_linpack_float",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32p4_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c5_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_i2c_master0",
        "tests": 6,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 1,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_fs0",
        "tests": 51,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_linpack_double",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32p4_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_fibonacci",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32s2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_uart0",
        "tests": 12,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c5_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_coremark",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c3_sdcard0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      }
    ],
    "tests": 86,
    "tests_succ": 74,
    "tests_skip": 0,
    "tests_fail": 1,
    "tests_error": 11,
    "runs": 1376,
    "runs_succ": 1364,
    "runs_skip": 0,
    "runs_fail": 1,
    "runs_error": 11,
    "commit": "411b5b1909ca5f6254aa8d455ecee99ed56fdb1b"
  },
  "annotations": [
    {
      "path": "performance/ramspeed/test_ramspeed.py",
      "start_line": 7,
      "end_line": 7,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/ramspeed/esp32s2/ramspeed.xml‚ÄÉ[took 3s]",
      "title": "1 out of 7 runs with error: test_ramspeed (performance.ramspeed.test_ramspeed)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x79f6e3333680>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x79f6e3462180>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x79f6e333a020>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x79f6e3354890>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/ramspeed/build.tmp/ramspeed.ino.bootloader.bin'>), (327...rtitions.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/ramspeed/build.tmp/ramspeed.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xaaP\\x01\\x02\\x00\\x90\\x00\\x00\\x00P\\x00\\x00nvs\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa...ff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...\\xcej\\x10\\xba\\xd4\\xc7\\xd1iC\\xaf\\x9b3\\x0b[8\\x98y', '/root/.arduino/tests/esp32s2/ramspeed/build.tmp/ramspeed.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "performance/linpack_double/test_linpack_double.py",
      "start_line": 5,
      "end_line": 5,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/linpack_double/esp32s2/linpack_double.xml‚ÄÉ[took 3s]",
      "title": "1 out of 7 runs with error: test_linpack_double (performance.linpack_double.test_linpack_double)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7dac63c03740>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7dac63c02b10>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7dac63c0e0c0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x7dac63bb4fe0>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/linpack_double/build.tmp/linpack_double.ino.bootloader....'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/linpack_double/build.tmp/linpack_double.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xaaP\\x01\\x02\\x00\\x90\\x00\\x00\\x00P\\x00\\x00nvs\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa...ff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...6\\xcaQ\\x98\\x98\\x1d\"\\x0b\\xdf\\xe5\\xb8', '/root/.arduino/tests/esp32s2/linpack_double/build.tmp/linpack_double.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "performance/superpi/test_superpi.py",
      "start_line": 5,
      "end_line": 5,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/superpi/esp32s2/superpi.xml‚ÄÉ[took 3s]",
      "title": "1 out of 7 runs with error: test_superpi (performance.superpi.test_superpi)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7d571221b3e0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7d571221a7b0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7d5712222020>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x7d571223c7d0>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/superpi/build.tmp/superpi.ino.bootloader.bin'>), (32768...partitions.bin'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/superpi/build.tmp/superpi.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\x00\\x00P\\...00\\x00\\x00U\\xdb\\x14\\xd3?\\xaa\\xaa7w\\xa9\\xf5\\xeb\\xad\\xd2\\x06K@\\xb4\\x15\\x8a\\xc4\\xd8\\xeew\\x15\\x83\\x83\\xda\\xa9\\x84w\\xe1\\xe4'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...\\xd3y\\xca\\xe2\\x1d\\xe0*\\xe0|\\\\\\xd0\\x06\\x13\\xd3\\xe9', '/root/.arduino/tests/esp32s2/superpi/build.tmp/superpi.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "validation/psram/test_psram.py",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/psram/esp32c5/psram.xml‚ÄÉ[took 0s]",
      "title": "test_psram (validation.psram.test_psram) with error",
      "raw_details": "failed on setup with \"ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x723962452900>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x723962452630>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x72396245a020>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_arduino.serial.ArduinoSerial object at 0x723962453470>\npexpect_proc = <pytest_embedded.log.PexpectProcess object at 0x723962452510>\nmsg_queue = <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x723962452630>\ntarget = 'esp32c5', beta_target = None, port = None, port_serial_number = None\nport_mac = None, baud = 115200, esptool_baud = 921600, esp_flash_force = False\nskip_autoflash = False, erase_all = False\nmeta = Meta(logdir='/tmp/pytest-embedded/2026-01-17_00-55-50-723404/test_psram', port_target_cache={}, port_app_cache={}, logfile_extension='.log')\nports_to_occupy = (), kwargs = {}, filters = {}, port_filter = ''\navailable_ports = [], ports = []\n\n    def __init__(\n        self,\n        pexpect_proc: PexpectProcess,\n        msg_queue: MessageQueue,\n        target: str | None = None,\n        beta_target: str | None = None,\n        port: str | None = None,\n        port_serial_number: str | None = None,\n        port_mac: str | None = None,\n        baud: int = Serial.DEFAULT_BAUDRATE,\n        esptool_baud: int = ESPTOOL_DEFAULT_BAUDRATE,\n        esp_flash_force: bool = False,\n        skip_autoflash: bool = False,\n        erase_all: bool = False,\n        meta: Meta | None = None,\n        ports_to_occupy: list[str] = (),\n        **kwargs,\n    ) -> None:\n        self._meta = meta\n        filters = {}\n        if port_serial_number:\n            filters['serials'] = [s.strip() for s in port_serial_number.split(',') if s.strip()]\n    \n        esptool_target = beta_target or target or 'auto'\n        if port is None or port.endswith('*'):\n            port_filter = port.strip('*') if port else ''\n            available_ports = [_p for _p in esptool.get_port_list(**filters) if port_filter in _p]\n            ports = list(set(available_ports) - set(self.occupied_ports.keys()) - set(ports_to_occupy))\n    \n            # sort to make /dev/ttyS* ports before /dev/ttyUSB* ports\n            # esptool will reverse the list\n            ports.sort()\n            if port_mac:\n                for port in ports:\n                    if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                        ports = [port]\n                        break\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} cannot be found.')\n    \n            # prioritize the cache recorded target port\n            if esptool_target and self._meta:\n                ports.sort(key=lambda x: self._meta.hit_port_target_cache(x, esptool_target))\n    \n            logging.debug(f'Detecting ports from {\", \".join(ports)}')\n        else:\n            if port_mac:\n                if _is_port_mac_verified(pexpect_proc, port, port_mac, msg_queue):\n                    ports = [port]\n                else:\n                    raise ValueError(f'The specified MAC address {port_mac} binds with different port, not with {port}')\n            else:\n                ports = [port]\n    \n        # normal loader\n        if esptool_target not in ['auto', *ESPTOOL_CHIPS]:\n            raise ValueError(\n                f'esptool version {ESPTOOL_VERSION} not support target {esptool_target}\\n'\n                f'Supported targets: {ESPTOOL_CHIPS}'\n            )\n    \n        with contextlib.redirect_stdout(msg_queue):\n            self.esp = esptool.get_default_connected_device(\n                ports,\n                port=port,\n                connect_attempts=3,\n                initial_baud=baud,\n                chip=esptool_target,\n            )\n    \n        if not self.esp:\n>           raise ValueError('Couldn\\'t auto detect chip. Please manually specify with \"--port\"')\nE           ValueError: Couldn't auto detect chip. Please manually specify with \"--port\"\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:107: ValueError"
    },
    {
      "path": "performance/linpack_float/test_linpack_float.py",
      "start_line": 5,
      "end_line": 5,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/linpack_float/esp32s2/linpack_float.xml‚ÄÉ[took 3s]",
      "title": "1 out of 7 runs with error: test_linpack_float (performance.linpack_float.test_linpack_float)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: MD5 of file does not match data in flash!\"\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x751bbbc337a0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x751bbbb9a5d0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x751bbbc420c0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:505: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1184: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:119: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:98: in __init__\n    raise e\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial/serial.py:95: in __init__\n    self._start()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:35: in _start\n    self.flash()\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:147: in wrapper\n    ret = func(self, *args, **kwargs)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:57: in flash\n    esptool.main(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1032: in main\n    cli(args=args, esp=esp)\n/usr/local/lib/python3.12/site-packages/esptool/cli_util.py:229: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:402: in __call__\n    return super().__call__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1485: in __call__\n    return self.main(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/rich_click/rich_command.py:216: in main\n    rv = self.invoke(ctx)\n         ^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1873: in invoke\n    return _process_result(sub_ctx.command.invoke(sub_ctx))\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:1269: in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/core.py:824: in invoke\n    return callback(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/click/decorators.py:34: in new_func\n    return f(get_current_context(), *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:689: in write_flash_cli\n    write_flash(ctx.obj[\"esp\"], addr_filename, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nesp = <esptool.targets.esp32s2.ESP32S2StubLoader object at 0x751bbbc512b0>\naddr_data = [(4096, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/linpack_float/build.tmp/linpack_float.ino.bootloader.bi...in'>), (65536, <_io.BufferedReader name='/root/.arduino/tests/esp32s2/linpack_float/build.tmp/linpack_float.ino.bin'>)]\nflash_freq = '80m', flash_mode = 'dio', flash_size = '4MB'\nkwargs = {'compress': False, 'encrypt': False, 'encrypt_files': None, 'erase_all': False, ...}\ndata = b'\\xaaP\\x01\\x02\\x00\\x90\\x00\\x00\\x00P\\x00\\x00nvs\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa...ff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'\nnorm_addr_data = [(4096, (b'\\xe9\\x03\\x02/\\\\\\xa1\\x04@\\xee\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\\x01\\x10Q\\xfe?\\x90\\x12\\...13\\xa4\\xc8.\\x8f\\x1dN?\\x9b\\x89\\x08\\x8e', '/root/.arduino/tests/esp32s2/linpack_float/build.tmp/linpack_float.ino.bin'))]\nerase_all = False, encrypt = False, encrypt_files = None, compress = True\n\n    def write_flash(\n        esp: ESPLoader,\n        addr_data: list[tuple[int, ImageSource]],\n        flash_freq: str = \"keep\",\n        flash_mode: str = \"keep\",\n        flash_size: str = \"keep\",\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Write firmware or data to the SPI flash memory of an ESP device.\n    \n        Args:\n            esp: Initiated esp object connected to a real device.\n            addr_data: List of (address, data) tuples specifying where\n                to write each file or data in flash memory. The data can be\n                a file path (str), bytes, or a file-like object.\n            flash_freq: Flash frequency to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_mode: Flash mode to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n            flash_size: Flash size to set in the bootloader image header\n                (``\"keep\"`` to retain current).\n    \n        Keyword Args:\n            erase_all (bool): Erase the entire flash before writing.\n            encrypt (bool): Encrypt all files during flashing.\n            encrypt_files (list[tuple[int, ImageSource]] | None): List of\n                (address, data) tuples for files to encrypt individually.\n            compress (bool): Compress data before flashing.\n            no_compress (bool): Don't compress data before flashing.\n            force (bool): Ignore safety checks (e.g., overwriting bootloader, flash size).\n            ignore_flash_enc_efuse (bool): Ignore flash encryption eFuse settings.\n            no_progress (bool): Disable progress updates.\n        \"\"\"\n        # Normalize addr_data to use bytes\n        norm_addr_data = [(addr, get_bytes(data)) for addr, data in addr_data]\n    \n        # Set default values of optional arguments\n        erase_all: bool = kwargs.get(\"erase_all\", False)\n        encrypt: bool = kwargs.get(\"encrypt\", False)\n        encrypt_files: list[tuple[int, ImageSource]] | None = kwargs.get(\n            \"encrypt_files\", None\n        )\n        compress: bool = kwargs.get(\"compress\", False)\n        no_compress: bool = kwargs.get(\"no_compress\", False)\n        force: bool = kwargs.get(\"force\", False)\n        ignore_flash_enc_efuse: bool = kwargs.get(\"ignore_flash_enc_efuse\", False)\n        no_progress: bool = kwargs.get(\"no_progress\", False)\n    \n        # set compress based on default behaviour:\n        # -> if either \"compress\" or \"no_compress\" is set, honour that\n        # -> otherwise, set \"compress\" unless the stub flasher is disabled\n        if not compress and not no_compress:\n            compress = esp.IS_STUB\n    \n        if not force and esp.CHIP_NAME != \"ESP8266\" and not esp.secure_download_mode:\n            # Check if secure boot is active\n            if esp.get_secure_boot_enabled():\n                for address, _ in norm_addr_data:\n                    if address < 0x8000:\n                        raise FatalError(\n                            \"Secure Boot detected, writing to flash regions < 0x8000 \"\n                            \"is disabled to protect the bootloader. \"\n                            \"Use the force argument to override, \"\n                            \"please use with caution, otherwise it may brick your device!\"\n                        )\n            # Check if chip_id and min_rev in image are valid for the target in use\n            for _, (data, name) in norm_addr_data:\n                try:\n                    image = LoadFirmwareImage(esp.CHIP_NAME, data)\n                except (FatalError, struct.error, RuntimeError):\n                    continue\n                if image.chip_id != esp.IMAGE_CHIP_ID:\n                    msg = (\n                        \"Input does not contain\" if name is None else f\"'{name}' is not an\"\n                    )\n                    raise FatalError(\n                        f\"{msg} an {esp.CHIP_NAME} image. \"\n                        \"Use the force argument to flash anyway.\"\n                    )\n    \n                # this logic below decides which min_rev to use, min_rev or min/max_rev_full\n                if image.max_rev_full == 0:  # image does not have max/min_rev_full fields\n                    use_rev_full_fields = False\n                elif image.max_rev_full == 65535:  # image has default value of max_rev_full\n                    use_rev_full_fields = True\n                    if (\n                        image.min_rev_full == 0 and image.min_rev != 0\n                    ):  # min_rev_full is not set, min_rev is used\n                        use_rev_full_fields = False\n                else:  # max_rev_full set to a version\n                    use_rev_full_fields = True\n    \n                if use_rev_full_fields:\n                    rev = esp.get_chip_revision()\n                    if rev < image.min_rev_full or rev > image.max_rev_full:\n                        error_str = f\"'{name}' requires chip revision in range \"\n                        error_str += (\n                            f\"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - \"\n                        )\n                        if image.max_rev_full == 65535:\n                            error_str += \"max rev not set] \"\n                        else:\n                            error_str += (\n                                f\"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] \"\n                            )\n                        error_str += f\"(this chip is revision v{rev // 100}.{rev % 100})\"\n                        raise FatalError(\n                            f\"{error_str}. Use the force argument to flash anyway.\"\n                        )\n                else:\n                    # In IDF, image.min_rev is set based on Kconfig option.\n                    # For C3 chip, image.min_rev is the Minor revision\n                    # while for the rest chips it is the Major revision.\n                    if esp.CHIP_NAME == \"ESP32-C3\":\n                        rev = esp.get_minor_chip_version()\n                    else:\n                        rev = esp.get_major_chip_version()\n                    if rev < image.min_rev:\n                        raise FatalError(\n                            f\"'{name}' requires chip revision \"\n                            f\"{image.min_rev} or higher (this chip is revision {rev}). \"\n                            \"Use the force argument to flash anyway.\"\n                        )\n    \n        # In case we have encrypted files to write,\n        # we first do few sanity checks before actual flash\n        if encrypt or encrypt_files is not None:\n            do_write = True\n    \n            if not esp.secure_download_mode:\n                if esp.get_encrypted_download_disabled():\n                    raise FatalError(\n                        \"This chip has encrypt functionality \"\n                        \"in UART download mode disabled. \"\n                        \"This is the Flash Encryption configuration for Production mode \"\n                        \"instead of Development mode.\"\n                    )\n    \n                crypt_cfg_efuse = esp.get_flash_crypt_config()\n    \n                if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:\n                    log.print(f\"Unexpected FLASH_CRYPT_CONFIG value: {crypt_cfg_efuse:#x}\")\n                    do_write = False\n    \n                enc_key_valid = esp.is_flash_encryption_key_valid()\n    \n                if not enc_key_valid:\n                    log.print(\"Flash encryption key is not programmed.\")\n                    do_write = False\n    \n            # Determine which files list contain the ones to encrypt\n            files_to_encrypt = (\n                norm_addr_data\n                if encrypt is not None\n                else [(addr, get_bytes(data)) for addr, data in encrypt_files]\n            )\n    \n            if files_to_encrypt is not None:\n                for address, (data, name) in files_to_encrypt:\n                    if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:\n                        source = \"Input image\" if name is None else f\"'{name}'\"\n                        log.warning(\n                            f\"{source} (address {address:#x}) is not \"\n                            f\"{esp.FLASH_ENCRYPTED_WRITE_ALIGN} byte aligned, \"\n                            \"can't flash encrypted.\"\n                        )\n                        do_write = False\n    \n            if not do_write and not ignore_flash_enc_efuse:\n                raise FatalError(\n                    \"Can't perform encrypted flash write, \"\n                    \"consult Flash Encryption documentation for more information.\"\n                )\n        else:\n            if not force and esp.CHIP_NAME != \"ESP8266\":\n                # ESP32 does not support `get_security_info()` and `secure_download_mode`\n                if (\n                    esp.CHIP_NAME != \"ESP32\"\n                    and esp.secure_download_mode\n                    and bin(esp.get_security_info()[\"flash_crypt_cnt\"]).count(\"1\") & 1 != 0\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption and \"\n                        \"secure download mode enabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n                if (\n                    not esp.secure_download_mode\n                    and esp.get_encrypted_download_disabled()\n                    and esp.get_flash_encryption_enabled()\n                ):\n                    raise FatalError(\n                        \"WARNING: Detected flash encryption enabled and \"\n                        \"download manual encrypt disabled.\\n\"\n                        \"Flashing plaintext binary may brick your device! \"\n                        \"Use the force argument to override the warning.\"\n                    )\n    \n        flash_size = _set_flash_parameters(esp, flash_size)  # Set flash size parameters\n    \n        set_flash_size = (\n            flash_size_bytes(flash_size) if flash_size not in [\"detect\", \"keep\"] else None\n        )\n        if esp.secure_download_mode:\n            flash_end = set_flash_size\n        else:  # Check against real flash chip size if not in SDM\n            flash_end_str = detect_flash_size(esp)\n            flash_end = flash_size_bytes(flash_end_str)\n            if set_flash_size and flash_end and set_flash_size > flash_end:\n                log.warning(\n                    f\"Set flash_size {flash_size} \"\n                    f\"is larger than the available flash size of {flash_end_str}.\"\n                )\n    \n        # Verify file sizes fit in the set flash_size, or real flash size if smaller\n        flash_end = (\n            min(set_flash_size, flash_end) if set_flash_size and flash_end else flash_end\n        )\n        if flash_end is not None:\n            for address, (data, name) in norm_addr_data:\n                if address + len(data) > flash_end:\n                    source = \"Input image\" if name is None else f\"File '{name}'\"\n                    raise FatalError(\n                        f\"{source} (length {len(data)}) at offset \"\n                        f\"{address:#010x} will not fit in {flash_end} bytes of flash. \"\n                        \"Change the flash_size argument or flashing address.\"\n                    )\n    \n        if erase_all:\n            erase_flash(esp)\n        else:\n            for address, (data, _) in norm_addr_data:\n                write_end = address + len(data)\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                if bytes_over != 0:\n                    log.note(\n                        f\"Flash address {address:#010x} is not aligned \"\n                        f\"to a {esp.FLASH_SECTOR_SIZE:#x} byte flash sector. \"\n                        f\"{bytes_over:#x} bytes before this address will be erased.\"\n                    )\n                # Print the address range of to-be-erased flash memory region\n                log.print(\n                    \"Flash will be erased from {:#010x} to {:#010x}...\".format(\n                        address - bytes_over,\n                        div_roundup(write_end, esp.FLASH_SECTOR_SIZE)\n                        * esp.FLASH_SECTOR_SIZE\n                        - 1,\n                    )\n                )\n    \n        \"\"\"\n        Create a list describing all the files we have to flash.\n        Each entry holds an \"encrypt\" flag marking whether the file needs encryption or not.\n        This list needs to be sorted.\n    \n        First, append to each entry of our addr_data list the flag \"encrypt\"\n        E.g., if addr_data is [(0x1000, \"partition.bin\"), (0x8000, \"bootloader\")],\n        all_files will be [\n            (0x1000, data, \"partition.bin\", encrypt),\n            (0x8000, data, \"bootloader\", encrypt)\n            ],\n        where, of course, encrypt is either True or False\n        \"\"\"\n        all_files = [(addr, data, name, encrypt) for (addr, (data, name)) in norm_addr_data]\n    \n        \"\"\"\n        Now do the same with encrypt_files list, if defined.\n        In this case, the flag is True\n        \"\"\"\n        if encrypt_files is not None:\n            encrypted_files_flag = [\n                (addr, *get_bytes(data), True) for (addr, data) in encrypt_files\n            ]\n    \n            # Concatenate both lists and sort them.\n            # As both list are already sorted, we could simply do a merge instead,\n            # but for the sake of simplicity and because the lists are very small,\n            # let's use sorted.\n            all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])\n    \n        for address, data, name, encrypted in all_files:\n            compress = compress\n    \n            # Check whether we can compress the current file before flashing\n            if compress and encrypted:\n                source = \"input bytes\" if name is None else f\"'{name}'\"\n                log.print(\"\\n\")\n                log.warning(\"Compress and encrypt options are mutually exclusive.\")\n                log.print(f\"Will flash {source} uncompressed.\")\n                compress = False\n    \n            image = data\n    \n            if len(image) == 0:\n                log.warning(\n                    \"Input bytes are empty.\" if name is None else f\"'{name}' is empty.\"\n                )\n                continue\n    \n            image = pad_to(image, esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4)\n    \n            if not esp.IS_STUB:\n                log.print(\"Erasing flash...\")\n    \n                # It is not possible to write to not aligned addresses without stub,\n                # so there are added 0xFF (erase) bytes at the beginning of the image\n                # to align it.\n                bytes_over = address % esp.FLASH_SECTOR_SIZE\n                address -= bytes_over\n                image = b\"\\xff\" * bytes_over + image\n    \n            if not esp.secure_download_mode and not esp.get_secure_boot_enabled():\n                image = _update_image_flash_params(\n                    esp, address, flash_freq, flash_mode, flash_size, image\n                )\n            else:\n                log.warning(\n                    \"Security features enabled, so not changing any flash settings.\"\n                )\n            calcmd5 = hashlib.md5(image).hexdigest()\n            uncsize = len(image)\n            if compress:\n                uncimage = image\n                image = zlib.compress(uncimage, 9)\n                compsize = len(image)\n            original_image = image  # Save the whole image in case retry is needed\n            # Try again if reconnect was successful\n            log.stage()\n            for attempt in range(1, esp.WRITE_FLASH_ATTEMPTS + 1):\n                try:\n                    if compress:\n                        # Decompress the compressed binary a block at a time,\n                        # to dynamically calculate the timeout based on the real write size\n                        decompress = zlib.decompressobj()\n                        esp.flash_defl_begin(uncsize, compsize, address)\n                    else:\n                        esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)\n                    seq = 0\n                    bytes_sent = 0  # bytes sent on wire\n                    bytes_written = 0  # bytes written to flash\n                    t = time.time()\n    \n                    timeout = DEFAULT_TIMEOUT\n                    image_size = compsize if compress else uncsize\n                    while len(image) >= 0:\n                        if not no_progress:\n                            log.progress_bar(\n                                cur_iter=image_size - len(image),\n                                total_iters=image_size,\n                                prefix=f\"Writing at {address + bytes_written:#010x} \",\n                                suffix=f\" {bytes_sent}/{image_size} bytes...\",\n                            )\n                        if len(image) == 0:  # All data sent, print 100% progress and end\n                            break\n                        block = image[0 : esp.FLASH_WRITE_SIZE]\n                        if compress:\n                            # feeding each compressed block into the decompressor lets us\n                            # see block-by-block how much will be written\n                            block_uncompressed = len(decompress.decompress(block))\n                            bytes_written += block_uncompressed\n                            block_timeout = max(\n                                DEFAULT_TIMEOUT,\n                                timeout_per_mb(\n                                    ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed\n                                ),\n                            )\n                            if not esp.IS_STUB:\n                                # ROM code writes block to flash before ACKing\n                                timeout = block_timeout\n                            esp.flash_defl_block(block, seq, timeout=timeout)\n                            if esp.IS_STUB:\n                                # Stub ACKs when block is received,\n                                # then writes to flash while receiving the block after it\n                                timeout = block_timeout\n                        else:\n                            # Pad the last block\n                            block = block + b\"\\xff\" * (esp.FLASH_WRITE_SIZE - len(block))\n                            if encrypted:\n                                esp.flash_encrypt_block(block, seq)\n                            else:\n                                esp.flash_block(block, seq)\n                            bytes_written += len(block)\n                        bytes_sent += len(block)\n                        image = image[esp.FLASH_WRITE_SIZE :]\n                        seq += 1\n                    break\n                except SerialException:\n                    if attempt == esp.WRITE_FLASH_ATTEMPTS or encrypted:\n                        # Already retried once or encrypted mode is disabled because of\n                        # security reasons\n                        raise\n                    log.print(\"\\nLost connection, retrying...\")\n                    esp._port.close()\n                    log.print(\"Waiting for the chip to reconnect\", end=\"\")\n                    for _ in range(DEFAULT_CONNECT_ATTEMPTS):\n                        try:\n                            time.sleep(1)\n                            esp._port.open()\n                            log.print()  # Print new line which was suppressed by print(\".\")\n                            esp.connect()\n                            if esp.IS_STUB:\n                                # Hack to bypass the stub overwrite check\n                                esp.IS_STUB = False\n                                # Reflash stub because chip was reset\n                                esp = esp.run_stub()\n                            image = original_image\n                            break\n                        except SerialException:\n                            log.print(\".\", end=\"\", flush=True)\n                    else:\n                        raise  # Reconnect limit reached\n    \n            if esp.IS_STUB:\n                # Get the \"encrypted\" flag for the last file flashed\n                # Note: all_files list contains quadruplets like:\n                # (address: int, filename: str | None, data: bytes, encrypted: bool)\n                last_file_encrypted = all_files[-1][3]\n    \n                # Stub only writes each block to flash after 'ack'ing the receive,\n                # so do a final operation which will not be 'ack'ed\n                # until the last block has actually been written out to flash\n                if compress and not last_file_encrypted:\n                    esp.flash_defl_finish(reboot=False, timeout=timeout)\n                else:\n                    esp.flash_finish(reboot=False, timeout=timeout)\n    \n            # Skip sending flash_finish to ROM loader here,\n            # as it causes the loader to exit and run user code\n    \n            t = time.time() - t\n            speed_msg = \"\"\n            log.stage(finish=True)\n            if compress:\n                if t > 0.0:\n                    speed_msg = f\" ({uncsize / t * 8 / 1000:.1f} kbit/s)\"\n                log.print(\n                    f\"Wrote {uncsize} bytes ({bytes_sent} compressed) \"\n                    f\"at {address:#010x} in {t:.1f} seconds{speed_msg}.\"\n                )\n            else:\n                if t > 0.0:\n                    speed_msg = \" (%.1f kbit/s)\" % (bytes_written / t * 8 / 1000)\n                log.print(\n                    f\"Wrote {bytes_written} bytes at {address:#010x} in {t:.1f} \"\n                    f\"seconds{speed_msg}.\"\n                )\n    \n            if not encrypted and not esp.secure_download_mode:\n                try:\n                    res = esp.flash_md5sum(address, uncsize)\n                    if res != calcmd5:\n                        log.print(f\"Input MD5: {calcmd5}\")\n                        log.print(f\"Flash MD5: {res}\")\n                        if res == hashlib.md5(b\"\\xff\" * uncsize).hexdigest():\n                            raise FatalError(\n                                \"Write failed, the written flash region is empty.\"\n                            )\n>                       raise FatalError(\"MD5 of file does not match data in flash!\")\nE                       esptool.util.FatalError: MD5 of file does not match data in flash!\n\n/usr/local/lib/python3.12/site-packages/esptool/cmds.py:952: FatalError"
    },
    {
      "path": "validation/gpio/test_gpio.py",
      "start_line": 6,
      "end_line": 6,
      "annotation_level": "warning",
      "message": "./artifacts/test-results-wokwi-esp32s3-validation/validation/gpio/esp32s3/gpio.xml‚ÄÉ[took 36s]",
      "title": "1 out of 7 runs failed: test_gpio (validation.gpio.test_gpio)",
      "raw_details": "pexpect.exceptions.TIMEOUT: Not found \"Interrupt attached - FALLING edge\"\nBytes in current buffer (color code eliminated): HIGH after pinMode INPUT_PULLUP\nPlease check the full log here: /tmp/pytest-embedded/2026-01-17_00-22-43-005625/test_gpio/dut.log\nself = <pytest_embedded_wokwi.dut.WokwiDut object at 0x7f5c339801a0>\npattern = 'Interrupt attached - FALLING edge', expect_all = False\nnot_matching = (), return_what_before_match = False, args = (), kwargs = {}\npatterns = ['Interrupt attached - FALLING edge'], res = []\ndebug_str = 'Not found \"Interrupt attached - FALLING edge\"\\nBytes in current buffer (color code eliminated): HIGH after pinMode INPUT_PULLUP\\nPlease check the full log here: /tmp/pytest-embedded/2026-01-17_00-22-43-005625/test_gpio/dut.log'\n\n    @functools.wraps(func)\n    def wrapper(\n        self,\n        pattern,\n        *args,\n        expect_all: bool = False,\n        not_matching: list[str | re.Pattern] = (),\n        return_what_before_match: bool = False,\n        **kwargs,\n    ) -> Match | AnyStr | list[Match | AnyStr]:\n        if return_what_before_match and expect_all:\n            raise ValueError('`return_what_before_match` and `expect_all` cannot be `True` at the same time.')\n    \n        patterns = to_list(pattern)\n        res = []\n        while patterns:\n            try:\n>               index = func(self, pattern, *args, **kwargs)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/site-packages/pytest_embedded/dut.py:86: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/site-packages/pytest_embedded/dut.py:170: in expect_exact\n    return self.pexpect_proc.expect_exact(pattern, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/site-packages/pexpect/spawnbase.py:432: in expect_exact\n    return exp.expect_loop(timeout)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/site-packages/pexpect/expect.py:181: in expect_loop\n    return self.timeout(e)\n           ^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pexpect.expect.Expecter object at 0x7f5c339ffe50>\nerr = TIMEOUT(\"<pytest_embedded.log.PexpectProcess object at 0x7f5c33980830>\\nsearcher: searcher_string:\\n    0: b'Interrupt attached - FALLING edge'\")\n\n    def timeout(self, err=None):\n        spawn = self.spawn\n    \n        spawn.before = spawn._before.getvalue()\n        spawn.after = TIMEOUT\n        index = self.searcher.timeout_index\n        if index >= 0:\n            spawn.match = TIMEOUT\n            spawn.match_index = index\n            return index\n        else:\n            spawn.match = None\n            spawn.match_index = None\n            msg = str(spawn)\n            msg += '\\nsearcher: %s' % self.searcher\n            if err is not None:\n                msg = str(err) + '\\n' + msg\n    \n            exc = TIMEOUT(msg)\n            exc.__cause__ = None    # in Python 3.x we can use \"raise exc from None\"\n>           raise exc\nE           pexpect.exceptions.TIMEOUT: <pytest_embedded.log.PexpectProcess object at 0x7f5c33980830>\nE           searcher: searcher_string:\nE               0: b'Interrupt attached - FALLING edge'\nE           <pytest_embedded.log.PexpectProcess object at 0x7f5c33980830>\nE           searcher: searcher_string:\nE               0: b'Interrupt attached - FALLING edge'\n\n/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/site-packages/pexpect/expect.py:144: TIMEOUT\n\nThe above exception was the direct cause of the following exception:\n\ndut = <pytest_embedded_wokwi.dut.WokwiDut object at 0x7f5c339801a0>\nwokwi = <Wokwi: returncode: None args: []>\n\n    def test_gpio(dut: Dut, wokwi: Wokwi):\n        LOGGER = logging.getLogger(__name__)\n    \n        def test_read_basic():\n            dut.expect_exact(\"BTN read as HIGH after pinMode INPUT_PULLUP\")\n            wokwi.client.set_control(\"btn1\", \"pressed\", 1)\n            wokwi.client.serial_write(\"OK\\n\")  # Sync ack R1\n            dut.expect_exact(\"BTN read as LOW\")\n    \n            wokwi.client.set_control(\"btn1\", \"pressed\", 0)\n            wokwi.client.serial_write(\"OK\\n\")  # Sync ack R2\n            dut.expect_exact(\"BTN read as HIGH\")\n            LOGGER.info(\"GPIO read basic test passed.\")\n    \n        def test_write_basic():\n            dut.expect_exact(\"GPIO LED set to OUTPUT\")\n            assert wokwi.client.read_pin(\"led1\", \"A\")[\"value\"] == 0  # Anode pin\n            wokwi.client.serial_write(\"OK\\n\")  # Sync ack W1\n    \n            dut.expect_exact(\"LED set to HIGH\")\n            assert wokwi.client.read_pin(\"led1\", \"A\")[\"value\"] == 1\n            wokwi.client.serial_write(\"OK\\n\")  # Sync ack W2\n    \n            dut.expect_exact(\"LED set to LOW\")\n            assert wokwi.client.read_pin(\"led1\", \"A\")[\"value\"] == 0\n            LOGGER.info(\"GPIO write basic test passed.\")\n    \n        def test_interrupt_attach_detach():\n            dut.expect_exact(\"Interrupt attached - FALLING edge\")\n    \n            for i in range(1, 4):\n                wokwi.client.set_control(\"btn1\", \"pressed\", 1)\n                wokwi.client.serial_write(f\"OK:{i}\\n\")\n                dut.expect_exact(f\"{i} interrupt triggered successfully\")\n                wokwi.client.set_control(\"btn1\", \"pressed\", 0)\n    \n            dut.expect_exact(\"Interrupt detached\")\n            wokwi.client.set_control(\"btn1\", \"pressed\", 1)\n            sleep(0.1)\n            dut.expect_exact(\"No interrupt triggered after detach\")\n            wokwi.client.set_control(\"btn1\", \"pressed\", 0)\n            wokwi.client.serial_write(\"OK\\n\")\n            LOGGER.info(\"GPIO interrupt attach/detach test passed.\")\n    \n        def test_interrupt_falling():\n            dut.expect_exact(\"Testing FALLING edge interrupt\")\n            for i in range(1, 4):\n                wokwi.client.set_control(\"btn1\", \"pressed\", 1)\n                wokwi.client.serial_write(f\"OK:{i}\\n\")\n                dut.expect_exact(f\"{i} FALLING edge interrupt worked\")\n                wokwi.client.set_control(\"btn1\", \"pressed\", 0)\n    \n            dut.expect_exact(\"Testing FALLING edge END\")\n            wokwi.client.serial_write(\"OK\\n\")\n            LOGGER.info(\"GPIO interrupt falling test passed.\")\n    \n        def test_interrupt_rising():\n            dut.expect_exact(\"Testing RISING edge interrupt\")\n    \n            for i in range(1, 4):\n                wokwi.client.set_control(\"btn1\", \"pressed\", 1)\n                wokwi.client.set_control(\"btn1\", \"pressed\", 0)\n                wokwi.client.serial_write(f\"OK:{i}\\n\")\n                dut.expect_exact(f\"{i} RISING edge interrupt worked\")\n    \n            dut.expect_exact(\"Testing RISING edge END\")\n            wokwi.client.serial_write(\"OK\\n\")\n            LOGGER.info(\"GPIO interrupt rising test passed.\")\n    \n        def test_interrupt_change():\n            dut.expect_exact(\"Testing CHANGE edge interrupt\")\n    \n            for i in range(1, 4):\n                wokwi.client.set_control(\"btn1\", \"pressed\", 1)\n                wokwi.client.serial_write(f\"OK:{i * 2 - 1}\\n\")\n                dut.expect_exact(f\"{i * 2 - 1} CHANGE edge interrupt worked\")\n    \n                wokwi.client.set_control(\"btn1\", \"pressed\", 0)\n                wokwi.client.serial_write(f\"OK:{i * 2}\\n\")\n                dut.expect_exact(f\"{i * 2} CHANGE edge interrupt worked\")\n    \n            dut.expect_exact(\"Testing CHANGE edge END\")\n            wokwi.client.serial_write(\"OK\\n\")\n            LOGGER.info(\"GPIO interrupt change test passed.\")\n    \n        def test_interrupt_with_arg():\n            dut.expect_exact(\"Testing interrupt with argument\")\n    \n            for i in range(1, 4):\n                wokwi.client.set_control(\"btn1\", \"pressed\", 1)\n                wokwi.client.serial_write(f\"OK:{i}\\n\")\n                dut.expect_exact(f\"{i} interrupt with argument worked, received arg: {42 + i - 1}\")\n                wokwi.client.set_control(\"btn1\", \"pressed\", 0)\n            dut.expect_exact(\"Testing interrupt with argument END\")\n            wokwi.client.serial_write(\"OK\\n\")\n            LOGGER.info(\"GPIO interrupt with argument test passed.\")\n    \n        LOGGER.info(\"Waiting for GPIO test begin...\")\n        dut.expect_exact(\"GPIO test START\")\n        test_read_basic()\n        test_write_basic()\n        dut.expect_exact(\"GPIO interrupt START\")\n>       test_interrupt_attach_detach()\n\ntests/validation/gpio/test_gpio.py:109: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/validation/gpio/test_gpio.py:35: in test_interrupt_attach_detach\n    dut.expect_exact(\"Interrupt attached - FALLING edge\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pytest_embedded_wokwi.dut.WokwiDut object at 0x7f5c339801a0>\npattern = 'Interrupt attached - FALLING edge', expect_all = False\nnot_matching = (), return_what_before_match = False, args = (), kwargs = {}\npatterns = ['Interrupt attached - FALLING edge'], res = []\ndebug_str = 'Not found \"Interrupt attached - FALLING edge\"\\nBytes in current buffer (color code eliminated): HIGH after pinMode INPUT_PULLUP\\nPlease check the full log here: /tmp/pytest-embedded/2026-01-17_00-22-43-005625/test_gpio/dut.log'\n\n    @functools.wraps(func)\n    def wrapper(\n        self,\n        pattern,\n        *args,\n        expect_all: bool = False,\n        not_matching: list[str | re.Pattern] = (),\n        return_what_before_match: bool = False,\n        **kwargs,\n    ) -> Match | AnyStr | list[Match | AnyStr]:\n        if return_what_before_match and expect_all:\n            raise ValueError('`return_what_before_match` and `expect_all` cannot be `True` at the same time.')\n    \n        patterns = to_list(pattern)\n        res = []\n        while patterns:\n            try:\n                index = func(self, pattern, *args, **kwargs)\n            except (pexpect.EOF, pexpect.TIMEOUT) as e:\n                debug_str = (\n                    f'Not found \"{pattern!s}\"\\n'\n                    f'Bytes in current buffer (color code eliminated): {self.pexpect_proc.buffer_debug_str}\\n'\n                    f'Please check the full log here: {self.logfile}'\n                )\n>               raise e.__class__(debug_str) from e\nE               pexpect.exceptions.TIMEOUT: Not found \"Interrupt attached - FALLING edge\"\nE               Bytes in current buffer (color code eliminated): HIGH after pinMode INPUT_PULLUP\nE               Please check the full log here: /tmp/pytest-embedded/2026-01-17_00-22-43-005625/test_gpio/dut.log\n\n/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/site-packages/pytest_embedded/dut.py:93: TIMEOUT"
    },
    {
      "path": "performance.superpi",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/superpi/esp32c6/superpi_missing_0.xml",
      "title": "missing-run (performance.superpi) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "performance.ramspeed",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/ramspeed/esp32c6/ramspeed_missing_0.xml",
      "title": "missing-run (performance.ramspeed) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "performance.linpack_float",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/linpack_float/esp32c6/linpack_float_missing_0.xml",
      "title": "missing-run (performance.linpack_float) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "performance.linpack_double",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/linpack_double/esp32c6/linpack_double_missing_0.xml",
      "title": "missing-run (performance.linpack_double) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "performance.fibonacci",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/fibonacci/esp32c6/fibonacci_missing_0.xml",
      "title": "missing-run (performance.fibonacci) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": "performance.coremark",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./test_errors/test-results-hardware/tests/performance/coremark/esp32c6/coremark_missing_0.xml",
      "title": "missing-run (performance.coremark) with error",
      "raw_details": "Expected test run missing\nThis placeholder indicates an expected test run did not execute."
    },
    {
      "path": ".github",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "notice",
      "message": "There are 86 tests, see \"Raw output\" for the full list of tests.",
      "title": "86 tests found",
      "raw_details": "auto_baudrate_test\nbasic_transmission_test\nbegin_when_running_test\nchange_baudrate_test\nchange_clock\nchange_cpu_frequency_test\nchange_pins_test\ndisabled_uart_calls_test\nenabled_uart_calls_test\nend_when_stopped_test\nhardware_flow_control_test\nperformance.coremark ‚Äë missing-run\nperformance.coremark.test_coremark ‚Äë test_coremark\nperformance.fibonacci ‚Äë missing-run\nperformance.fibonacci.test_fibonacci ‚Äë test_fibonacci\nperformance.linpack_double ‚Äë missing-run\nperformance.linpack_double.test_linpack_double ‚Äë test_linpack_double\nperformance.linpack_float ‚Äë missing-run\nperformance.linpack_float.test_linpack_float ‚Äë test_linpack_float\nperformance.psramspeed.test_psramspeed ‚Äë test_psramspeed\nperformance.ramspeed ‚Äë missing-run\nperformance.ramspeed.test_ramspeed ‚Äë test_ramspeed\nperformance.superpi ‚Äë missing-run\nperformance.superpi.test_superpi ‚Äë test_superpi\nperiman_test\npsram_found\nresize_buffers_test\nrtc_run_clock\nrtc_set_time\nscan_bus\nscan_bus_with_wifi\nswap_pins\ntest_api\ntest_append_behavior\ntest_basic_write_and_read\ntest_binary_incremental_with_size_tracking\ntest_binary_write_and_seek\ntest_calloc_success\ntest_dir_ops_and_list\ntest_directory_operations_edge_cases\ntest_empty_file_operations\ntest_error_cases\ntest_fail\ntest_file_truncation_and_overwrite\ntest_free_space_tracking\ntest_info_sanity\ntest_large_file_operations\ntest_malloc_fail\ntest_malloc_success\ntest_max_open_files_limit\ntest_memcpy\ntest_memset_all_ones\ntest_memset_all_zeroes\ntest_memset_alternating\ntest_memset_random\ntest_multiple_file_handles\ntest_nonexistent_spi_interface\ntest_pass\ntest_realloc_success\ntest_rename_and_remove\ntest_sd_basic\ntest_sd_dir\ntest_sd_directory_listing\ntest_sd_file_append_operations\ntest_sd_file_count_in_directory\ntest_sd_file_operations\ntest_sd_file_size_operations\ntest_sd_large_file_operations\ntest_sd_nested_directories\ntest_sd_open_limit\ntest_seek_edge_cases\ntest_touch_errors\ntest_touch_interrtupt\ntest_touch_read\ntest_write_read_patterns\ntimer_clock_select_test\ntimer_divider_test\ntimer_interrupt_test\ntimer_read_test\nvalidation.democfg.test_democfg ‚Äë test_cfg\nvalidation.gpio.test_gpio ‚Äë test_gpio\nvalidation.hello_world.test_hello_world ‚Äë test_hello_world\nvalidation.nvs.test_nvs ‚Äë test_nvs\nvalidation.periman.test_periman ‚Äë test_periman\nvalidation.psram.test_psram ‚Äë test_psram\nvalidation.wifi.test_wifi ‚Äë test_wifi"
    }
  ],
  "check_url": "https://github.com/espressif/arduino-esp32/runs/60648324431",
  "formatted": {
    "stats": {
      "files": "228",
      "errors": [],
      "suites": "228",
      "duration": "9‚Äà640",
      "suite_details": [
        {
          "name": "performance_hardware_esp32h2_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32c5_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_democfg1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_psram0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_timer0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_timer0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_psram0",
          "tests": 8,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_superpi",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_psram0",
          "tests": 8,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32p4_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_ramspeed",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c6_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_i2c_master0",
          "tests": 6,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32h2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_linpack_float",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32p4_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c5_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_i2c_master0",
          "tests": 6,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 1,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_fs0",
          "tests": 51,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_linpack_double",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32p4_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_fibonacci",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32s2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_uart0",
          "tests": 12,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c5_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_coremark",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c3_sdcard0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        }
      ],
      "tests": "86",
      "tests_succ": "74",
      "tests_skip": "0",
      "tests_fail": "1",
      "tests_error": "11",
      "runs": "1‚Äà376",
      "runs_succ": "1‚Äà364",
      "runs_skip": "0",
      "runs_fail": "1",
      "runs_error": "11",
      "commit": "411b5b1909ca5f6254aa8d455ecee99ed56fdb1b"
    }
  }
}